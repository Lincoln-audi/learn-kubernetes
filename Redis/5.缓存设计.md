缓存击穿


一个并发访问量比较大的key在某个时间过期，导致所有的请求直接打在DB上。

![image](https://github.com/Lincoln-dac/kube-linux/blob/master/pic/6401.png)


解决方案：

1.加锁更新，⽐如请求查询A，发现缓存中没有，对A这个key加锁，同时去数据库查询数据，写⼊缓存，再返回给⽤户，这样后⾯的请求就可以从缓存中拿到数据了。图片
![image](https://github.com/Lincoln-dac/kube-linux/blob/master/pic/6402.png)

2.将过期时间组合写在value中，通过异步的⽅式不断的刷新过期时间，防⽌此类现象。





缓存穿透



缓存穿透指的查询缓存和数据库中都不存在的数据，这样每次请求直接打到数据库，就好像缓存不存在一样。
![image](https://github.com/Lincoln-dac/kube-linux/blob/master/pic/6403.png)

缓存穿透将导致不存在的数据每次请求都要到存储层去查询，失去了缓存保护后端存储的意义。

缓存穿透可能会使后端存储负载加大，如果发现大量存储层空命中，可能就是出现了缓存穿透问题。

缓存穿透可能有两种原因：

自身业务代码问题
恶意攻击，爬虫造成空命中
它主要有两种解决办法：

缓存空值
一种方式是在数据库不命中之后，把一个空对象或者默认值保存到缓存，之后再访问这个数据，就会从缓存中获取，这样就保护了数据库。


![image](https://github.com/Lincoln-dac/kube-linux/blob/master/pic/6403.png)



缓存空值有两大问题：

1.空值做了缓存，意味着缓存层中存了更多的键，需要更多的内存空间（如果是攻击，问题更严重），比较有效的方法是针对这类数据设置一个较短的过期时间，让其自动剔除。

2.缓存层和存储层的数据会有一段时间窗口的不一致，可能会对业务有一定影响。例如过期时间设置为5分钟，如果此时存储层添加了这个数据，那此段时间就会出现缓存层和存储层数据的不一致。这时候可以利用消息队列或者其它异步方式清理缓存中的空对象。

布隆过滤器除了缓存空对象，我们还可以在存储和缓存之前，加一个布隆过滤器，做一层过滤。
布隆过滤器里会保存数据是否存在，如果判断数据不不能再，就不会访问存储。

![image](https://github.com/Lincoln-dac/kube-linux/blob/master/pic/6406.png)


两种解决方案的对比：

![image](https://github.com/Lincoln-dac/kube-linux/blob/master/pic/64111.png)


缓存雪崩

某一时刻发大规模的缓存失效的情况，例如缓存服务宕机、大量key在同一时间过期，这样的后果就是⼤量的请求进来直接打到DB上，可能导致整个系统的崩溃，称为雪崩。

![image](https://github.com/Lincoln-dac/kube-linux/blob/master/pic/64111.png)

缓存雪崩是三大缓存问题里最严重的一种，我们来看看怎么预防和处理。

提高缓存可用性
1。集群部署：通过集群来提升缓存的可用性，可以利用Redis本身的Redis Cluster或者第三方集群方案如Codis等。
2.多级缓存：设置多级缓存，第一级缓存失效的基础上，访问二级缓存，每一级缓存的失效时间都不同。
过期时间
1.均匀过期：为了避免大量的缓存在同一时间过期，可以把不同的 key 过期时间随机生成，避免过期时间太过集中。
2.热点数据永不过期。
熔断降级
1.服务熔断：当缓存服务器宕机或超时响应时，为了防止整个系统出现雪崩，暂时停止业务服务访问缓存系统。
2.服务降级：当出现大量缓存失效，而且处在高并发高负荷的情况下，在业务系统内部暂时舍弃对一些非核心的接口和数据的请求，而直接返回一个提前准备好的 fallback（退路）错误处理信息。
